[{"title":"createStore","date":"2017-08-24T09:32:25.000Z","path":"2017/08/24/createStore/","text":"What is Store 用过Redux，Vuex等状态管理机之后，肯定对Store的理念有所了解；Store就是单页面应用中保存公用数据的容器； 应用中经常实用的state就是某个时间点Store生成的快照，可以通过store.getState()获得； 用户只能通过View层发送Action来更改Store中的公用数据，而store.dispatch(),是View发出Action的唯一办法； Store通过Reducer在接收到一个Action后，更新相应的公用数据； 数据更新后，对应的View也要做相应的更新，Store.subscribe(listener)设置监听函数，一旦数据变化,就自动执行这个函数,所以只要将View的更新函数放入listener，就会实现View层的自动渲染； store.subscribe()返回一个函数，执行此函数就可以解除监听： 1234567891011121314151617181920212223242526272829 var unsubscribe = store.subscribe(); unsubscribe(); ``` # What is createStore doing?* 实际应用中要通过createStore函数生成一个Store，那这个函数到底做了什么呢？阮一峰老师解释的很清晰，我这边搬来做一下笔记： ```javascript const createStore = function(reducer)&#123; var state; var listeners = []; const getState = function()&#123;return state&#125;; const dispatch = function(action)&#123; state = reducer(state, action); listeners.forEach(listener =&gt; listener()); &#125;; const subscribe = function(listener)&#123; listeners.push(listener); return () =&gt; &#123; listeners = listeners.filter(l =&gt; l !== listener); &#125; &#125;; dispatch(&#123;&#125;); return &#123; getState, dispatch, subscribe &#125;; &#125;","tags":[{"name":"React","slug":"React","permalink":"https://barefootChild.github.io/tags/React/"},{"name":"Redux","slug":"Redux","permalink":"https://barefootChild.github.io/tags/Redux/"}]},{"title":"Debounce And Throttle ","date":"2017-08-04T01:38:25.000Z","path":"2017/08/04/Debounce-And-Throttle/","text":"debounce调用某函数一段时间后才会执行，如果在这段期间再调用该函数则重新计算执行时间： 12345678910function debounce(time, func) &#123; var previous; return function() &#123; var that = this, args = arguments; clearTimeout(previous); previous = setTimeout(function()&#123; func.apply(that, args); &#125;, time); &#125;&#125; throttle设定一个函数执行时间间隔，只有当前执行时间与上次执行时间的时间间隔大于设定的执行时间间隔，函数才会执行： 12345678910function throttle(delay, func) &#123; var last = 0; return function() &#123; var current = +(new Date()); if (current - last &gt; delay) &#123; func.apply(this, func); last = current; &#125; &#125;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"front-end","slug":"front-end","permalink":"https://barefootChild.github.io/tags/front-end/"},{"name":"Function","slug":"Function","permalink":"https://barefootChild.github.io/tags/Function/"}]},{"title":"Regex","date":"2017-06-05T08:39:47.000Z","path":"2017/06/05/Regex/","text":"正则表达式 之前学习正则表达式时，还在犯嘀咕：学这玩意有什么用？验证邮箱，手机号？除了这些地方丝毫感觉不到用武之地；所以粗略地学了一下，现在忘得差不多了，遇到问题直接就去百度了，直到我看到下面的这些用法，才发现自己的无知，不禁感叹果然正则大法好！ 获取链接http://www.baidu.com?name=jawil&amp;age=23name的value的值 非正则实现： 1234567891011function getParamName(attr) &#123; var search = window.location.search; var param_str = search.split('?')[1]; var param_arr = param_str.split('&amp;'); var filter_arr = param_arr.filter(function(ele) &#123; return ele.split('=')[0] === attr; &#125;); return decodeURIComponent(filter_arr[0].split('=')[1]);&#125;console.log(getParamName('name')); 正则实现： 123456function getParamName(attr) &#123; var match = RegExp(`[?&amp;]$&#123;attr&#125;=([^&amp;]*)`).exec(window.location.search); return match &amp;&amp; decodeURIComponent(match[1].replace(/\\+/g, ' '));&#125;console.log(getParamName('name')); 数字格式化问题， 1234567890 –&gt; 1,234,567,890 非正则实现： 123456789101112131415var test = '1234567890';function formatCash(str) &#123; var arr = []; for (var i = 1; i &lt; str.length; i++) &#123; if (str.length % 3 &amp;&amp; i === 1) &#123; arr.push(str.substr(0, str.length % 3)); &#125; if (i % 3 === 0) &#123; arr.push(str.substr(i - 2, 3)); &#125; &#125; return arr.join(',');&#125;console.log(formatCash(test)); 正则实现： 123var test1 = '1234567890';var format = test1.replace(/\\B(?=(\\d&#123;3&#125;)+(?!\\d))/g, ',');console.log(format) 下面简单分析一下正则/\\B(?=(\\d{3})+(?!\\d))/g: /\\B(?=(\\d{3})+(?!\\d))/g：正则匹配边界\\B，边界后面必需跟着(\\d{3})+(?!\\d)； (\\d{3})+：必需是1个或多个的3个连续数字； (?!\\d): 第2步中的3个数字不允许后面跟着数字； (\\d{3})+(?!\\d): 所以匹配的边界后面必须跟着3*n(n&gt;=1)的数字；最终把匹配到的所有边界换成,即可达成目标。 用正则去掉字符串左右两边的空格， ‘ zys cq’ –&gt; ‘zys cq’(字符串原生的trim方法，也没毛病啊，不知道，原文作者为什么单独拿出来用正则实现了一下) 123456function regexTrim(str) &#123; return str.replace(/(^\\s*)|(\\s*$)/g, '');&#125;var str = ' zys cq ';console.log(regexTrim(str)); 看完大牛们的正则使用后，得给自己安排点时间重新学习Regex了！","tags":[{"name":"Javascript","slug":"Javascript","permalink":"https://barefootChild.github.io/tags/Javascript/"},{"name":"Regex","slug":"Regex","permalink":"https://barefootChild.github.io/tags/Regex/"}]},{"title":"fetch","date":"2017-05-25T02:12:24.000Z","path":"2017/05/25/fetch/","text":"fetch fetch是web异步通信的未来，但是目前部分浏览器对它还不太支持，其中chrome42-45，对中文支持有问题，建议从chrome46起使用fetch；对于IE8+浏览器，建议依次安装下列垫片：原文地址 es5的polyfill － es5-shim，es5-sham. Promise的polyfill - es6-promise. fetch的polyfill － fetch－ie8. Promise特性 fetch方法返回一个Promise对象，所以fetch可以方便地使用then方法将各个处理逻辑串起来，使用Promise.resolve()或者Promise.reject()方法将分别返回肯定结果的Promise或否定结果的Promise，从而调用下一个then或者catch。一旦then中的语句出现错误，也将跳到catch中。 response type 一个fetch请求的响应类型(response.type)为如下三种之一： basic cors opaque同域下，响应类型为basic；跨域下，服务器没有返回CORS响应头，响应类型为opaque。此时我们不能查看任何有价值的信息，比如不能查看response，status，url等等。同样是跨域下，如果服务器返回了CORS响应头，那么响应信息将为cors。此时响应头中除Cache-Control,Content-Language,Content-Type,Expores,Last-Modified和Progma之外的字段都不可见；但是，无论是同域还是跨域，fetch请求都到达了服务器； mode fetch可以设置不同模式使得请求有效，该值可以在fetch方法第二个参数对象中定义： 1fetch(url, &#123;mode: 'cors'&#125;); 可定义的模式如下： same-origin: 表示同域下可请求成功；反之，浏览器将拒绝发送本次fetch，同时抛出错误TypeError:Failed to fetch(…). cors: 表示同域和带有CORS响应头的跨域下可请求成功。其他请求将被拒绝。 cors-with-forced-preflight: 表示在发出请求之前，将进行preflight检查。 no-cors: 常用于跨域请求不带CORS响应头场景，此时响应类型为opaque。 header fetch获取http响应头： 123fetch(url).then(function(response) &#123; console.log(response.headers.get('Content-Type'));&#125;); 设置http请求： 12345var headers = new Headers();headers.append('Content-Type', 'text/html');fetch(url, &#123; headers: headers&#125;) 检索header的内容： 12345var header = new Headers(&#123; \"Content-Type\": 'text/plain'&#125;);console.log(header.has('Content-Type'));console.log(header.has('Content-Length')); post 在fetch中发送post请求，在fetch方法第二个参数对象中设置： 12345678910var headers = new Headers();headers.append('Content-Type', 'application/json;charset=UTF-8');fetch(url, &#123; method: 'post', headers: headers, body: JSON.stringify(&#123; date: '2016-10-08', time: '15:16:00' &#125;)&#125;); credentials 跨域请求中需要带有cookie时，需要在fetch方法的第二个参数对象中添加credentials属性(include)： omit: 默认值； same-origin: 同源，表示同域请求才发送cookie； catch 同XMLHttpRequest一样，无论服务器返回什么样的状态码，都不会进入错误捕获。也就是说，XMLHttpRequest实例是不会触发onerror事件回调的，fetch不会触发reject。通常只在网络出现问题或者ERR_CONNECTION_RESET时，他们才会进入到相应的错误捕获里。 cache cache表示如何处理缓存，遵守http规范，拥有如下几种值： default: 表示fetch请求之前将检查一下http的缓存； no-store: 表示fetch请求将完全忽略http缓存的存在。即请求之前不再检查http缓存，拿到响应后也不会更新http缓存； no-cache: 如果存在缓存，那么fetch将发送一个条件查询request和一个正常的request，拿到响应后，会更新http缓存； reload: 表示fetch请求之前将忽略http缓存的存在，但是请求拿到后它将主动更新http缓存； force-cache: 表示不顾一切的依赖缓存，即使缓存过期了，他依然从缓存中读取。除非没有缓存，那么他将发送一个正常的request； only-if-cached: 表示fetch请求不顾一切地依赖缓存，即使缓存过期了，如果没有缓存，它将抛出网络错误（该设置只在mode为same-origin时有效）；如果fetch请求的header里包含If-Modified-Since,If-None-Match,If-Unmodified-Since,If-Match,或者If-Range之一，且cache的值为default，那么fetch将自动把cache的值设置为no-store","tags":[{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"front-end","slug":"front-end","permalink":"https://barefootChild.github.io/tags/front-end/"},{"name":"fetch","slug":"fetch","permalink":"https://barefootChild.github.io/tags/fetch/"},{"name":"request","slug":"request","permalink":"https://barefootChild.github.io/tags/request/"}]},{"title":"Ajax","date":"2017-05-18T08:19:47.000Z","path":"2017/05/18/Ajax/","text":"前后端分离的基石Ajax 现代浏览器几乎都支持ajax，但是实现的技术分为两种：原文地址 标准浏览器通过XMLHttpRequest对象实现了ajax功能，创建一个用于发送ajax请求的对象只需要一条语句： 1var xhr = new XMLHttpRequest(); IE浏览器通过XMLHttpRequest或者ActiveXObject对象实现ajax功能； 1234567891011121314151617function getXHR() &#123; var xhr; if (window.XMLHttpRequest) &#123; xhr = new XMLHttpRequest(); &#125; else if (window.ActiveXObject) &#123; try &#123; xhr = new ActiveXObject(\"Msxml2.XMLHTTP\"); &#125; catch (e) &#123; try &#123; xhr = new ActiveXObject(\"Microsoft.XMLHTTP\"); &#125; catch (e) &#123; alert('您的浏览器暂时不支持Ajax！'); &#125; &#125; &#125; return xhr;&#125; 所以，为了迎合各大浏览器刁钻的口味，我们不得不提供兼容的方法; ajax有没有破坏js单线程机制 关于这个问题我们就要先研究一下浏览器的单线程机制。一般情况下的，浏览器四线程： GUI渲染线程 javascript引擎线程 浏览器事件触发线程 HTTP请求线程这么多线程，他们是如何同js引擎线程交互的呢？通常，线程之间交互以事件的方式发生，通过事件回调的方式予以通知，事件回调又是以先进先出的方式添加到任务队列末尾的，等js引擎空闲时，任务队列中排队的任务将会依次被执行。这些事件回调包括setTimeout,setInterval,click,ajax异步请求等回调。 浏览器中，js引擎线程会循环从任务队列中读取事件并执行，这种运行机制称为Event Loop（事件循环） 详细讲一下，发送一个ajax请求，浏览器内部线程的执行情况： 对于一个ajax请求，js引擎首先生成XMLHttpRequest实例对象，open过后在调用send方法。至此，所有的语句都是同步执行的，但是从send方法内部开始，浏览器就为即将发生的网络请求创建了新的http请求线程，这个线程独立于js引擎线程，于是网络请求异步被发送出去了。js引擎并不会等待ajax发起的http请求收到结果而是直接顺序往下执行； 当ajax请求被服务器响应并且接受到response后，浏览器事件触发线程捕获到了ajax的回调事件onreadystatechange。该回调事件并没有被立即执行，而是先被添加到任务队列的末尾。直到js引擎空闲了，任务队列的任务才会被捞出来按照先来后到的顺序，依次执行（包括刚刚append到队列末尾的onreadystatechange事件） 在onreadystatechange事件内部，有可能对dom进行操作。此时浏览器便会挂起js引擎线程，转而执行GUI渲染线程，进行UI repaint者reflow。当js引擎重新执行时，GUI渲染线程又会被挂起，GUI更新将会被保存起来，等到js引擎空闲时立即被执行； 所以整个ajax请求过程中，有涉及到浏览器的四种线程，只有GUI渲染线程和js引擎线程是互斥的。其他线程之间都是可以并行执行的。通过这种方式，ajax并没有破坏js的单线程机制。 ajax与setTimeout排队问题 通常，ajax和setTimeout的事件回调都是被同等的对待，按照顺序自动被添加到任务队列的末尾，等待js引擎空闲时执行。但是，并非所有的回调执行都滞后于setTimeout的回调; 由于ajax异步，setTimeout回调本应该最先被执行，然而实际上，一次ajax请求，并非所有的部分都是异步的，至少’readyState == 1’的onreadystatechange回调以及onloadstart回调就是同步执行的. XHR一级 XHR1时，xhr对象具有如下缺点： 仅支持文本数据传输，无法传输二进制数据； 传输数据时，没有进度信息提示，只能提示是否完成； 受浏览器同源策略限制，只能请求同源资源； 没有超时机制，不方便掌握ajax请求节奏； XHR二级(IE10及更高版本) 支持二进制数据，可以上传文件，可以使用FormData对象管理表单； 提供进度提示，可以通过xhr.upload.onprogress事件回调函数获取传输进度； 依然受同源策略限制，这个安全机制不会变。XHR2新提供Access-Control-Allow-Origin等headers，设置为＊时表示允许任何域名请求，从而实现跨域CORS访问； 可以设置timeout及ontimeout，方便设置超时时长和超时后续处理； $.ajax $.ajax是jquery对原生ajax的一次封装。通过封装ajax，jquery抹平了不同浏览器异步http的差异性，取而代之的是高度统一的api。$.ajax()只有一个参数，该参数为key－value设置对象。实际上，jquery发送的所有ajax请求，都是通过该ajax方法实现的。 Axios 实际上，如果仅仅是想使用一个不错的http库，精致的Axios相比较于庞大臃肿的jquery会更合适： Axios支持node，jquery并不支持； Axios基于promise语法； Axios更适合http场景，jquery大而全，加载较慢； Fetch 说到ajax，就不得不说一下fetch，具体内容请看下篇博客； 什么是CORS CORS是一个W3C标准，跨域资源共享。允许浏览器向跨域服务器，发出异步http请求，从而克服了ajax受同源策略的限制。实际上，浏览器并不会拦截不合法的跨域请求，而是拦截了他们的响应。 HTML启用CORS http-equiv相当于http的响应头，他回应给浏览器一些有用的信息，以帮助正确和精确地显示网页内容。下面的html将允许任意域名下的网页跨域访问： &lt;meta http-equiv=&quot;Access-Control-Allow-Origin&quot; content=&quot;*&quot;&gt;","tags":[{"name":"Ajax","slug":"Ajax","permalink":"https://barefootChild.github.io/tags/Ajax/"},{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"front-end","slug":"front-end","permalink":"https://barefootChild.github.io/tags/front-end/"}]},{"title":"CSS-BFC","date":"2017-05-04T11:12:47.000Z","path":"2017/05/04/CSS-BFC/","text":"什么是BFC？ 之前对于css理解不够深，碰到一些样式问题，虽然通过查资料可以达到预期的效果，但是对背后的原理理解不够深刻；比如：父元素设置overflow:hidden,可以清除浮动；同级块元素之间的margin覆盖；还有一些元素设置了某些属性后就没有按照预期的效果展示，等；这些都有可能是由于某些属性触发了该元素的BFC呈现了BFC的默认样式渲染规则；BFC就是css布局的一个概念，是一块区域，一个环境；接下来就来稍微研究一下BFC； BFC的定义： BFC（Block formatting context），”块级格式化上下文”，是一个独立的渲染区域，规定了内部的Block-level Box如何布局，与这个区域外部毫不相干； 我们常说的文档流有三种，定位流，浮动流和普通流；而普通流就是指BFC中的FC。 FC就是格式化上下文，它是页面中的一块渲染区域，有一套渲染规则，决定了其子元素如何布局，以及和其他元素之间的关系和作用； 常见的FC有BFC、IFC（行级格式化上下文），还有GFC（网格布局格式化上下文）和FFC（自适应格式化上下文），有兴趣的可以自行了解； 简单点的解释 BFC 可以简单的理解为某个元素的一个 CSS 属性，只不过这个属性不能被开发者显式的修改，拥有这个属性的元素对内部元素和外部元素会表现出一些特性，这就是BFC； 触发条件或者说哪些元素会生成BFC 满足下列条件之一就可以出发BFC： 根元素，即HTML元素； float的值不为none； overflow的值不为visible； display的值为inline-block,table-cell,table-caption,(flex); position的值为fixed或absolute； BFC布局规则： 内部的Box会在垂直方向，一个接一个地放置; Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠; 每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此; BFC的区域不会与float box重叠; BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此 计算BFC的高度时，浮动元素也参与计算; BFC的作用： 自适应两栏布局; 可以阻止元素被浮动元素覆盖; 可以包含浮动元素——清除内部浮动; 分属于不同的BFC时可以阻止margin重叠; BFC与Layout IE 作为浏览器中的奇葩，当然不可能按部就班的支持 BFC 标准，于是乎 IE 中有了 Layout 这个东西。Layout 和 BFC 基本是等价的，为了处理 IE 的兼容性，在需要触发 BFC 时，我们除了需要用触发条件中的CSS 属性来触发 BFC，还需要针对 IE 浏览器使用 zoom: 1 来触发 IE 浏览器的 Layout；","tags":[{"name":"front-end","slug":"front-end","permalink":"https://barefootChild.github.io/tags/front-end/"},{"name":"CSS","slug":"CSS","permalink":"https://barefootChild.github.io/tags/CSS/"},{"name":"BFC","slug":"BFC","permalink":"https://barefootChild.github.io/tags/BFC/"}]},{"title":"functionCurrie","date":"2017-04-27T05:43:07.000Z","path":"2017/04/27/functionCurrie/","text":"javascript函数柯里化 在计算机语言中，柯里化，就是把接受多个参数的函数变换成接受一个单一参数的函数，并且返回接受余下的参数而且返回结果的新函数的技术。 eg: 12345678910function add(a, b) &#123; return a + b;&#125;function curryingAdd(a, b)&#123; return function(b) &#123; return a + b; &#125;&#125;add(1, 2); // 3curryingAdd(1)(2); // 3 上面的函数add是一般的函数，将传进来的参数进行相加；函数curryingAdd就是对函数add进行柯里化的函数； 函数的柯里化能够让我们重新组合自己的应用，可以把复杂功能拆分成一个一个小的部分，每一个小的部分都是简单的，便于理解的，而且是容易测试的； 如何对函数进行柯里化？(涉及知识：闭包，高阶函数，不完全函数等) 蠢萌皮卡丘123456789101112function printInfo(name, song) &#123; console.log(name + '最喜欢的歌曲是：' + song);&#125;printInfo('Tom', '七里香');printInfo('Jerry', '雅俗共赏');function curryingPrintInfo(name) &#123; return function(song) &#123; console.log(name + '最喜欢的歌曲是：' + song); &#125;&#125;curryingPrintInfo('Tom')('七里香');curryingPrintInfo('Jerry')('雅俗共赏'); 皮卡丘进化上面虽然实现了函数柯里化，但是当我们需要柯里化的时候，都要像上面那样不断地进行函数嵌套，那就是噩梦；所以下面就提供一个帮助其他函数进行柯里化的函数； 123456789// 高阶函数function curryingHelper(fn) &#123; var _args = Array.prototype.slice.call(arguments, 1); return function() &#123; var _newArgs = Array.prototype.slice.call(arguments); var _totalArgs = _args.concat(_newArgs); return fn.apply(this, _totalArgs); &#125;&#125; 检测上面辅助柯里化函数的正确性： 12345function showMsg(name, age, fruit) &#123; console.log('My name is ' + name + ', I\\'m ' + age + ' years old, ' + ' and I like eat ' + fruit);&#125;curryingHelper(showMsg, 'zys')(22, 'apple'); // My name is zys, I'm 22 years old, and I like eat applecurryingHelper(showMsg, 'glj')(22, 'banana'); // My name is glj, I'm 22 years old, and I like eat banana 皮卡丘超级进化上面的函数柯里化基本能满足我们的一般性需求了，但是如果我们希望那些经过柯里化的函数可以每次只传递一个参数，然后可以进行多次参数的传递，该怎么办呢？ 12345678910111213function betterCurryingHelper(fn, len) &#123; var length = len || fn.length; return function() &#123; var allArgsFulfilled = (arguments.length &gt;= length); // 如果参数全部满足，终止递归调用 if (allArgsFulfilled) &#123; return fn.apply(this, arguments); &#125; else &#123; var argsNeedFulFilled = [fn].concat(Array.prototype.slice.call(arguments)); return betterCurryingHelper(curryingHelper.apply(this, argsNeedFulFilled), length - arguments.length); &#125; &#125;&#125; fn.length代表这个函数定义时的参数长度;下面检测一下上面更屌的辅助柯里化函数； 1234betterCurryingHelper(showMsg)('zys', 22, 'apple');betterCurryingHelper(showMsg)('zys')(22)('apple');betterCurryingHelper(showMsg)('zys', 22)('apple');betterCurryingHelper(showMsg)('zys')(22, 'apple'); 皮卡丘究极进化（让人炸毛）最刺激的柯里化函数莫过于传参时不按照顺序了： 12345678910111213141516171819202122232425262728293031323334353637383940414243var _ = &#123;&#125;;function crazyCurryingHelper(fn, length, args, holes) &#123; var length = length || fn.length; var args = args || []; var holes = holes || []; return function() &#123; var _args = args.slice(); var _holes = holes.slice(); var argLength = _args.length; var holeLength = _holes.length; var allArgumentsSpecified = false; var arg = null, i = 0, aLength = arguments.length; for(; i &lt; aLength; i++) &#123; arg = arguments[i]; if (arg === _ &amp;&amp; holeLength) &#123; holeLength--; _holes.push(_holes.shift()); &#125; else if (arg === _) &#123; _holes.push(argLength + i); &#125; else if (holeLength) &#123; holeLength--; _args.splice(_holes.shift(), 0, arg); &#125; else &#123; _args.push(arg); &#125; &#125; allArgumentsSpecified = (_args.length &gt;= length); if (allArgumentsSpecified) &#123; return fn.apply(this, _args); &#125; return crazyCurryingHelper.call(this, fn, length, _args, _holes); &#125;;&#125; 检测一下上面比较疯狂的辅助柯里化函数： 12345crazyCurryingHelper(showMsg)(_, 22)('zys')('apple');crazyCurryingHelper(showMsg)(_, 22, 'apple')('zys');crazyCurryingHelper(showMsg)(_, 22, _)('zys', _, 'apple');crazyCurryingHelper(showMsg)('zys', _, _)(22)('apple');crazyCurryingHelper(showMsg)('zys')(22)('apple'); 关于柯里化的性能 使用柯里化意味着有一些额外的开销;这些开销一般涉及到这些方面,首先是关于函数参数的调用,操作arguments对象通常会比操作命名的参数要慢一点; 还有,在一些老的版本的浏览器中arguments.length的实现是很慢的;直接调用函数fn要比使用fn.apply()或者fn.call()要快一点;产生大量的嵌套,作用域还有闭包会带来一些性能还有速度的降低.但是,大多数的web应用的性能瓶颈时发生在操作DOM上的,所以上面的那些开销比起DOM操作的开销还是比较小的. 琐碎知识点 fn.length:表示函数fn定义时参数的个数； arguments.callee:指当前运行的函数； fn.caller: 返回调用指定函数的函数；","tags":[{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"function","slug":"function","permalink":"https://barefootChild.github.io/tags/function/"},{"name":"currie","slug":"currie","permalink":"https://barefootChild.github.io/tags/currie/"},{"name":"arguments","slug":"arguments","permalink":"https://barefootChild.github.io/tags/arguments/"}]},{"title":"cookie","date":"2017-04-18T12:06:36.000Z","path":"2017/04/18/cookie/","text":"Cookie cookie是存储于访问者计算机中的变量，当该台计算机通过浏览器请求某个界面时，就会发送这个cookie。你可以使用JavaScript来创建和取回cookie的值；cookie是访问过的网站创建文件，用于存储浏览信息，例如个人信息，账号密码等； 从JavaScript的角度来看，cookie就是一些字符串信息。这些信息存在客户端的计算机中，用于客户端和服务器之间传递信息。在JavaScript中可以通过document.cookie来读取或者设置这些信息。 基础知识 cookie是有大小限制的。每个cookie所存放的数据不能超过4k，如果cookie字符串的长度超过4k，则该属性将返回空字符串； cookie最终是以文件形式存放在客户端计算机中的，可以对cookie进行查看和修改，所以cookie不能存放重要的信息； cookie存在有效期，默认关闭浏览器，cookie的生命周期结束；当然cookie的有效期可以自定义； cookie有域和路径的概念；一般情况下cookie不能跨域访问(可以通过一些手段达到二般情况)；路径问题就是指：一个网页创建的cookie只能被这个网页同一目录或者子目录下的所有页面访问，而不能被其他目录下的网页访问。 创建cookie和创建变量的方式相似，都需要使用cookie的名称和cookie值；同个网站可以创建多个cookie，多个cookie可以存放在同一个cookie文件中。 常见问题 cookie存在两种类型 浏览的当前网站本身设置的cookie 来自网页嵌入广告或图片等其他来源的，第三方cookie(网页通过使用这些cookie跟踪你的使用信息) cookie的生命周期 临时性的cookie。使用过程中存储一些个人信息，浏览器关闭后cookie信息将会被删除； 设置失效时间的cookie。失效时间根据自己需求设定(登录名和密码)； cookie的两种清除方式 通过浏览器工具清除cookie(浏览器自身功能，有第三方工具)； 设置cookie的有效期自动清除cookie； 删除cookie有时候可能导致某些网页无法运行； 浏览器通过设置来接受和拒绝访问cookie； 尽量减少cookie的使用量，并且尽量使用小cookie，考虑到功能和性能问题； 设置cookie的有效期 通过expires设置cookie的有效期： 1document.cookie = 'name=zys;expires=date'; 上面代码的date的值为GMT格式的日期型字符串，生成方式： 123var _date = new Date();_date.setDate(_date.getDate() + 30); // cookie有效期为30天_date.toGMTString(); 高级篇路径概念 cookie一般是由用户访问的界面创建的，可是并不是只有在创建cookie的页面才可以访问该cookie，默认情况下同目录或者子目录的网页才可以访问； 通过设置cookie的路径就可以实现该cookie被其他目录或者父级目录访问； eg：设置路径为根目录 1document.cookie = 'name=zys;path=/' 域概念 cookie实现同域访问的问题： 使cookie在a:www.qq.com和b:sports.qq.com同时可以被访问 1document.cookie = 'name=zys;path=/;domain=qq.com' 安全性 一般情况下cookie的信息都是使用http连接传递数据的，这种方式很容易被查看，cookie存储的信息容易被获取；如果一个cookie的属性为secure，它就会通过 https或者其他安全协议进行传输； 1document.cookie = 'name=zys;secure'; 把cookie设置为secure，只保证cookie在与服务器间数据传输过程加密，保存在本地的cookie文件并不加密(可以自己加密)； 编码细节 在输入cookie信息时，不能包含空格、分号、逗号等特殊符号，一般情况下，cookie信息的存储都是采用为编码的形式。所以在设置cookie信息之前，要先使用 escape()函数将cookie信息进行编码，在取得到cookie值的时候，再使用unescape()函数把值转换回来： 12document.cookie = name = '=' + escape(value);return unescape(document.cookie.substring(start, end));","tags":[{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"cookie","slug":"cookie","permalink":"https://barefootChild.github.io/tags/cookie/"}]},{"title":"prototype && __proto__","date":"2017-04-07T09:30:26.000Z","path":"2017/04/07/prototype/","text":"概念 prototype是函数(function)的一个属性，他指向函数的原型； proto是对象内部的一个属性，他只想构造器的原型，对象依赖他进行原型链查询； 所以，prototype只有函数才有，其他对象(非函数)不具有该属性，而proto是对象的内部属性，任何对象都拥有该属性； 上个栗子吧123456789function Person(name) &#123; this.name = name;&#125;var p1 = new Person('zys');console.log(Person.prototype);//Person原型&#123;constructor: Person(name),__proto__: Object&#125;console.log(p1.prototype);//undefinedconsole.log(Person.__proto__);//空函数，function()&#123;&#125;console.log(p1.__proto__ === Person.prototype);//true 剥栗子的过程中我们发现，Person.prototype(原型)默认两个属性： constructor属性，指向构造器，即Person本身 proto属性指向一个空的Object对象 p1是非函数对象，自然就没有prototype属性； Person.proto属性指向的是一个空函数(function(){}); p1proto属性指向的是构造器(Person)的原型，即Person.prototype; 对象的原型链查询时正是通过这个属性(proto)链接到构造器的原型，从而实现查询的层层深入； protoPerson.proto指向的是一个空函数，但是这个空函数究竟是什么：1console.log(Person.__proto__ === Function.prototype);//true Person是构造器也是函数，Person的proto属性自然就指向函数(function)的原型，即Function.prototype.这说明所有的构造器都继承于Function.prototype，甚至包括根构造器Object及Function自身，所有的构造器都继承了Function.prototype的属性及方法。如length、call、apply、bind(ES5)等。如下:123456789console.log(Number.__proto__ === Function.prototype); // trueconsole.log(Boolean.__proto__ === Function.prototype); // trueconsole.log(String.__proto__ === Function.prototype); // trueconsole.log(Object.__proto__ === Function.prototype); // trueconsole.log(Function.__proto__ === Function.prototype); // trueconsole.log(Array.__proto__ === Function.prototype); // trueconsole.log(RegExp.__proto__ === Function.prototype); // trueconsole.log(Error.__proto__ === Function.prototype); // trueconsole.log(Date.__proto__ === Function.prototype); // true javascript中内置构造器/对象共计13个，上面是可直接访问的9个构造器。还有Global不能直接访问，Arguments仅在函数调用时由js引擎创建，Math、JSON是以对象的形式存在的，无需new。他们的proto属性指向构造器函数的原型(Object.prototype);12console.log(Math.__proto__ === Object.prototype); // trueconsole.log(JSON.__proto__ === Object.prototype); // true Function.prototype1console.log(typeof Function.prototype)//function Function.prototype是唯一一个prototype的类型为function的prototype,其他构造器的prototype都是一个对象；如下:12345678console.log(typeof Number.prototype) // objectconsole.log(typeof Boolean.prototype) // objectconsole.log(typeof String.prototype) // objectconsole.log(typeof Object.prototype) // objectconsole.log(typeof Array.prototype) // objectconsole.log(typeof RegExp.prototype) // objectconsole.log(typeof Error.prototype) // objectconsole.log(typeof Date.prototype) // object JS函数是一等公民1console.log(Function.Prototype.__proto__ === Object.prototype)//true 所以，所有的构造器既是函数又是普通JS对象，可以给构造器添加删除属性；同时他也继承了Object.prototype上的所有方法：toString、valueOf、hasOwnProperty等； Object.prototypePerson.proto -&gt; Function.prototype;Function.prototype.proto -&gt; Object.prototype;Object.prototype.proto -&gt; null;所以javascript的源头是null，果然”万物皆空啊！”","tags":[]},{"title":"mobileQuestion","date":"2017-03-17T08:10:03.000Z","path":"2017/03/17/mobileQuestion/","text":"移动端屏幕适配的解决 随着手机硬件配置的飞速发展、屏幕尺寸的越来越大和网络带宽的逐渐提升，越来越多的PC业务和服务在向移动端转移。然而在这种移动端的时代，该如何处理各终端 屏幕的适配呢？ 设置meta标签meta之viewport，其主要用来告诉浏览器如何规范的渲染Web页面，而你则需要告诉它视窗有多大。在开发移动端页面，我们需要在html中设置meta标签如下： 1&lt;meta name=\"viewport\" content=\"width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0\"&gt; 手淘的flexibleflexible是一个制作H5适配的开源库，需要在html中引入，可以直接使用阿里CDN： 1&lt;script src=\"http://g.tbcdn.cn/mtb/lib-flexible/0.3.4/??flexible_css.js,flexible.js\"&gt;&lt;/script&gt; 执行这个JS后，会在元素上增加一个data－dpr属性，以及一个font-size样式。JS会根据不同的设备添加不同的data－dpr值，比如说1、2、3，同时会给html加上对应的font-size 的值，比如说37.5px 放弃px拥抱remem的计算是基于父级元素的，在实际中给我们的计算带来了很大的不方便。但是rem是始终基于根元素html的；刚刚我们引入了手淘的flexible，并给html加了font-size，如此以来，页面中的元素就可以通过rem单位来设置了。会根据html元素的font-size值做相应的计算，从而实现屏幕的适配效果。 css处理器(SASS)可以使用Sass的函数、混合宏来实现： 123@function px2rem($pr, $base-font-size: 75px)&#123; @return ($px / $base-font-size) * 1rem&#125; 这里的这个参数$base-font-size: 75px,可以通过设计稿宽度／10来计算；假如宽为750，则$base-font-size为75px； 使用： 1234.box &#123; width: px2rem(190px); height: px2rem(190px);&#125; 移动端1px的解决方法 what is 1px question?Retine屏的分辨率始终是普通屏幕的2倍，1px的边框在devicePixelRatio = 2的retina屏幕下会显示为2px。 解决方案： transform: scaleY() 123456789101112131415161718192021222324252627282930313233&lt;div class=\"border-1px\"&gt;&lt;/div&gt;&lt;style type=\"text/scss\"&gt; .border-1px &#123; position: relative; &amp;:after &#123; display: block; position: absolute; left: 0; bottom: 0; width: 100%; border-top: 1px solid #000; content: ''; &#125; &#125; @media (-webkit-min-device-pixel-ratio: 1.5),(min-device-pixel-ratio: 1.5) &#123; .border-1px&#123; &amp;::after &#123; -webkit-transform: scaleY(0.7); transform: scaleY(0.7); &#125; &#125; &#125; @media (-webkit-min-device-pixel-ratio: 2),(min-device-pixel-ratio: 2) &#123; .border-1px &#123; &amp;::after &#123; -webkit-transform: scaleY(0.5); transform: scaleY(0.5); &#125; &#125; &#125;&lt;/style&gt;","tags":[{"name":"mobile","slug":"mobile","permalink":"https://barefootChild.github.io/tags/mobile/"}]},{"title":"constructor","date":"2017-03-17T05:53:33.000Z","path":"2017/03/17/constructor/","text":"构造函数在`JavaScript`中，new关键字可以让一个函数变得与众不同；eg: 12345function demo() &#123; console.log(this);&#125;demo(); // windownew demo(); // demo 很显然，使用new之后，函数内部发生了一些微妙的变化，改变了this的指向；但是new关键字到底做了什么呢？可以简单地用四句话表述： 声明一个中间对象Object； 将中间对象的原型指向构造函数的原型； 将构造函数的this指向该中间对象,并执行构造函数内部的代码； 返回该中间对象，即返回实例对象； 这四句话该如何用代码表示呢？ 1234567891011121314151617181920212223242526272829//首先创建一个构造函数var Person = function(name, age) &#123; this.name = name; this.age = age; this.getName = function () &#123; return this.name; &#125;&#125;//模拟new关键字的执行过程，将构造函数以参数的形式传入function New(func) &#123; //声明一个中间对象，该对象为最终返回的实例 var res = &#123;&#125;; if (func.prototype !== null) &#123; //将该中间对象的原型指向该函数的原型 res.__proto__ = func.prototype; &#125; //ret为构造函数执行的结果，这里运用apply，将构造函数内部的this指向res，并执行构造函数内部的代码 var ret = func.apply(res, Array.prototype.slice.call(arguments, 1)); //如果我们在构造函数中指明了返回对象时，那么new的执行结果就是该返回对象 if ((typeof ret === 'object' || typeof ret === 'function') &amp;&amp; ret !== null) &#123; return ret; &#125; //如果没有明确指明返回对象，则默认返回res，这个res就是实例对象 return res;&#125;//通过new声明创建实例，这里的p1，实际接受的就是new返回的resvar p1 = New(Person, 'zys', 23);console.log(p1.getName()); //zysconsole.log(p1 instanceof Person); //true JavaScript内部再通过其他的特殊处理，将New(Person, &apos;zys&apos;, 23);等效于new Person(&apos;zys&apos;, 23); 这样new关键字的神秘面纱就这样被揭开了！！！","tags":[{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"constructor","slug":"constructor","permalink":"https://barefootChild.github.io/tags/constructor/"},{"name":"prototype","slug":"prototype","permalink":"https://barefootChild.github.io/tags/prototype/"},{"name":"this","slug":"this","permalink":"https://barefootChild.github.io/tags/this/"}]},{"title":"react-lifecycle","date":"2017-03-16T07:28:20.000Z","path":"2017/03/16/react-life/","text":"react生命周期详解 我们在使用react时，往往需要在组件渲染之前进行一些数据操作，来保证我们视图中展示的信息是正确的；那么，在哪里或者在什么时候操作数据才会被视图渲染时展示我们修改后的数据信息呢？操作数据的代码写在哪里才是正确的呢？这些问题在我们了解了组件的生命周期后就会豁然开朗了； 组件的各个生命周期 componentWillMount(){} Mounting安装阶段，在客户端和服务器上，在初始渲染发生之前立即调用一次，在这个方法中可以调用setState，render()函数将会渲染最新的的状态，但是只会执行一次； componentDidMount(){} Mounting安装阶段，只在客户端调用一次，在初始渲染发生后立即执行； componentWillReciveProps(nexProps){} Updating更新阶段，在组件接收新props时调用，初始渲染不调用此方法，旧的props可以使用this.props查看，新的prop使用nextProps查看，在此函数中调用this.setState()不会触发附加的渲染； shouldComponentUpdate(nextProps, nextState){} Updating更新阶段，当正在接收新的状态时，在渲染之前调用；此方法必须返回false或者true，否则报错，true则渲染，false则不渲染；在此生命周期中考虑是否进行渲染，避免不必要的性能浪费；如果返回false，render()将会被完全跳过，直到下一个状态改变。另外，不会调用componentWillUpdate和componentDidUpdate componentWillUpdate(nextProps, nextState){} Updating更新阶段，当正在接收新的props或state时立即调用，初始渲染不调用此方法； componentDidUpdate(nextProps, nextState){} Updating更新阶段，在组件的更新刷新到DOM后立即调用，初始渲染不调用此方法； componentWillUnmount(){} Unmounting卸载阶段，在组件从DOM卸载前立即调用，在此方法中执行任何必要的清理；","tags":[{"name":"react","slug":"react","permalink":"https://barefootChild.github.io/tags/react/"},{"name":"component","slug":"component","permalink":"https://barefootChild.github.io/tags/component/"},{"name":"lifecycle","slug":"lifecycle","permalink":"https://barefootChild.github.io/tags/lifecycle/"}]},{"title":"browsers-front-end","date":"2017-02-16T09:13:46.000Z","path":"2017/02/16/browsers-front-end/","text":"浏览器加载，解析，渲染了解浏览器加载、解析、渲染过程的意义 了解浏览器如何进行加载，可以使我们在引用外部样式文件，外部js时，将它们放到合适的位置，使浏览器以最快的速度将文件加载完毕。 了解浏览器如何进行解析，可以使我们在构建DOM结构，组织css选择器时，选择最优的写法，提高浏览器的解析速率。 了解浏览器如何进行渲染，明白渲染的过程，我们在设置元素属性，编写js文件时，可以减少重绘，重新布局的消耗。 浏览器是如何进行加载，解析，渲染的呢？ 用户访问网页，DNS服务器（域名解析系统）会根据用户提供的域名查找对应的IP地址，找到后，系统会向对应IP地址的网络服务器发送一个http请求。 网络服务器解析请求，并发送请求给数据库服务器。 数据库服务器将请求的资源返回给网络服务器，网络服务器解析数据，并生成html文件，放入http response中，返回给浏览器。 浏览器解析http response。 浏览器解析http response后，需要下载html文件，以及html文件内包含的外部引用文件，以及文件内涉及的图片或者多媒体文件。 加载 即获取资源文件的过程，不同浏览器，以及他们不同版本在实现这一过程时，会有不同的实现效果（资源之间相互阻塞）。加载过程中遇到外部css文件，浏览器另外发出一个请求，来获取css文件。遇到图片资源，浏览器也会另外发出请求，来获取图片资源。这是异步请求，不会影响到html文档进行加载，但是当文档加载过程中遇到js文件，html文档会挂起渲染（加载解析渲染同步）的线程，不仅要等待js文件加载完毕，还要等待解析执行完毕，才可以恢复html文档的渲染线程。 原因：JS有可能会修改DOM，最为经典的document.write，这意味着，在JS执行完成之前，后续所有资源的下载可能是没有必要的，这是js阻塞后续资源下载的根本原因。 方法：可以将外部引用的js文件放在&lt;/body&gt;前。 虽然css文件的加载不影响js文件的加载，但却影响js文件的执行，即使js文件内只有一行代码，也会造成阻塞。 原因：可能会有var width = $(&quot;#id&quot;).width()，这意味着，js代码执行前，浏览器必须保证css文件已下载和解析完成。这也是css阻塞后续js的根本原因。 方法：当js文件不需要依赖css文件时，可以将js文件放在头部css的前面。 解析 html文档解析生成解析树即DOM树，是由dom元素即节点组成，树的根是document对象。 css解析将css文件解析为样式表对象。 js解析 渲染 即为构建渲染树的过程，是原dom树的可视化表示，构建这棵树是为了以正确的的顺序绘制文档内容。 渲染树和DOM树的关系，不可见的dom元素不会被插入渲染树中。一些节点位置为绝对或浮动定位，这些节点会在文本流之外，因此会在两棵树的不同位置，渲染树标识出真实的位置，并用一个占位结构标识出他们原来的位置。 渲染最大的难题就是为每一个dom节点计算他的最终样式。为每一个元素查找到匹配的样式规则，需要遍历整个规则表； 样式数据是非常大的结构，保存数据很耗内存。 选择器迭代太深，造成太多的无用遍历。 样式规则涉及非常复杂的级联，定义了规则的层次。 根据对计算样式困难的理解，在编写css样式表时应该注意以下几点： dom深度尽量浅。 减少行内js、css的数量。 使用现代合法的css属性。 不要为id选择器指定类名或是标签，因为id可以唯一确定一个元素。 不要给类选择器指定标签，类，代表具有一类属性的标签，不仅一个，虽然可以实现，但是降低了效率。 避免后代选择符，尽量使用子选择符。原因：子选择符的概率要大于后代元素匹配符。 避免使用通配符。","tags":[{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"html","slug":"html","permalink":"https://barefootChild.github.io/tags/html/"},{"name":"css","slug":"css","permalink":"https://barefootChild.github.io/tags/css/"},{"name":"browser","slug":"browser","permalink":"https://barefootChild.github.io/tags/browser/"}]},{"title":"nodeSpider","date":"2017-02-08T06:32:28.000Z","path":"2017/02/08/nodeSpider/","text":"爬虫爬取豆瓣电影(Node.js)初学Node.js，实现对豆瓣电影top250进行爬取，参照Node.js爬取豆瓣电影 引入模块12345'use strict';let https = require('https'), fs = require('fs'), path = require('path'), cheerio = require('cheerio'); 创建https get请求123456789101112131415161718192021222324252627282930313233function spiderMovie(index) &#123; https.get('https://movie.douban.com/top250?start=' + index, (res) =&gt; &#123; let pageSize = 25; let html = ''; let movies = []; res.setEncoding('utf-8'); res.on('data', (chunk) =&gt; &#123; html += chunk; &#125;); res.on('end', () =&gt; &#123; let $ = cheerio.load(html); $('.item').each(() =&gt; &#123; let picUrl = $('.pic img', this).attr('src'); let movie = &#123; title: $('.title', this).text(), start: $('.info .star .rating_num', this).text(), link: $('a', this).attr('href'), picUrl: picUrl &#125;; if (movie) &#123; movies.push(movie); &#125; downloadImg('./img/', movie.picUrl); &#125;); saveData('./data' + (index / pageSize) + '.json', movies); &#125;); &#125;).on('error', (err) =&gt; &#123; console.log(err); &#125;);&#125; 下载图片1234567891011121314151617181920 function downloadImg(imgDir, url) &#123; https.get(url, (res) =&gt; &#123; let data = ''; res.setEncoding('binary'); res.on('data', (chunk) =&gt; &#123; data += chunk; &#125;); res.on('end', () =&gt; &#123; fs.writeFile(imgDir + path.basename(url), data, 'binary', (err) =&gt; &#123; if (err) &#123; return console.log(err); &#125; console.log('Image downloaded: ', path.basename(url)); &#125;); &#125;).on('error', (err) =&gt; &#123; console.log(err); &#125;); &#125;);&#125; 保存数据到本地12345678910function saveData(path, movies) &#123; console.log(movies); fs.writeFile(path, JSON.stringify(movies, null, ' '), (err) =&gt; &#123; if (err) &#123; return console.log(err); &#125; console.log('Data saved'); &#125;);&#125; 创建爬取生成器123456789function *doSpider(x) &#123; let start = 0; console.log(start + '_________'); while (start &lt; x) &#123; yield start; spiderMovie(start); start += 25; &#125;&#125; 执行爬取方法123for (let x of doSpider(250)) &#123; console.log(x);&#125; 详细代码已上传到本人github","tags":[{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"node","slug":"node","permalink":"https://barefootChild.github.io/tags/node/"},{"name":"spider","slug":"spider","permalink":"https://barefootChild.github.io/tags/spider/"},{"name":"es6","slug":"es6","permalink":"https://barefootChild.github.io/tags/es6/"}]},{"title":"getElementPosition","date":"2017-02-07T07:05:53.000Z","path":"2017/02/07/getElementPosition/","text":"2017年以来的第一篇博客 开春以来事情比较少就搞起来自己的博客吧！浏览了阮一峰老师关于如何用javascript获取界面元素位置一篇文章为了加深印象并做一个笔记，就取其精华把知识写在自己的博客里方便自己查阅！ 一、获取网页大小： 网页上的每个元素都有clientHeight和clientWidth属性。这两个属性表示元素的content内容部分再加上padding的所占据的视觉面积，不包括border和滚动条占用的空间。 因此，document与纳素的clientHeight和clientWidth属性就代表了网页的大小： 12345678910111213function getViewport() &#123; if (document.compatMode === 'BackCompat') &#123; return &#123; width: document.body.clientWidth, height: document.body.clientHeight &#125; &#125; else &#123; return &#123; width: document.documentElement.clientWidth, height: document.documentElement.clientHeight &#125; &#125;&#125; 二、获取网页大小的另一种方法： 网页上的每个元素还有scrollHeight和scrollWidth属性，只包含滚动条在内的该元素的视觉面积。 所以，document对象的scrollHeight和scrollWidth属性就是网页的大小，但是当界面不出现滚动条时clientWidth和scrollWidth应该相等，但是实际上不同的浏览器有不同的处理；所以，我们要取它们之间最大的那个： 12345678910111213function getPageArea() &#123; if (document.compatMode === 'BackCompat') &#123; return &#123; width: Math.max(document.body.scrollWidth, document.body.clientWidth), height: Math.max(document.body.scrollHeight, document.body.clientHeight) &#125; &#125; else &#123; return &#123; width: Math.max(document.documentElement.scrollWidth, document.documentElement.clientWidth), height: Math.max(document.documentElement.scrollHeight, document.documentElement.clientHeight) &#125; &#125;&#125; 三、获取网页的绝对位置： 每个元素都有offsetTop和offsetLeft属性，表示该元素的左上角与父容器（offsetParent）左上角的距离； 所以，只要对这两个元素进行迭代就可以得到该元素的绝对坐标； 1234567891011121314151617181920212223function getElementLeft(ele) &#123; let actualLeft = ele.offsetLeft; let current = ele.offsetParent; while (current) &#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; return actualLeft;&#125;function getElementTop(ele) &#123; let actualTop = ele.offsetTop; let current = ele.offsetParent; while (current) &#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; return actualTop;&#125; 四、获取网页元素的相对位置： 获取到绝对位置后，获取相对位置就很容易了，减去界面滚动条滚动的距离就可以了： 123456789101112131415161718192021222324252627function getElementViewLeft(ele) &#123; let actualLeft = ele.offsetLeft; let current = ele.offsetParent; while (current) &#123; actualLeft += current.offsetLeft; current = current.offsetParent; &#125; let elementScrollLeft = document.compatMode === 'BackCompat' ? document.body.scrollLeft : document.documentElement.scrollLeft; return actualLeft - elementScrollLeft;&#125;function getElementViewTop(ele) &#123; let actualTop = ele.offsetTop; let current = ele.offsetParent; while (current) &#123; actualTop += current.offsetTop; current = current.offsetParent; &#125; let elementScrollTop = document.compatMode === 'BackCompat' ? document.body.scrollTop : document.documentElement.scrollTop; return actualTop - elementScrollTop;&#125; 五、获取元素位置的快速方法： getBoundingClientRect()方法，返回一个对象，其中包含了left,right,top,bottom四个属性，为相对位置，获取到相对位置之后就很容易获取绝对位置了！","tags":[{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"elementPosition","slug":"elementPosition","permalink":"https://barefootChild.github.io/tags/elementPosition/"}]},{"title":"ES6_vs_ES5","date":"2016-11-07T08:15:52.000Z","path":"2016/11/07/ES6-vs-ES5/","text":"原文地址: Overview of JavaScript ES6 features (a.k.a ECMAScript 6 and ES2015+) 原文作者: Adrian Mejia 译文地址: L9m JavaScript ES6 核心功能一览（ES6 亦作 ECMAScript 6 或 ES2015+） JavaScript 在过去几年里发生了很大的变化。我仅从原文里拿来几个比较实用的新功能(作为笔记来用),当然比较基础的如let const等,没有介绍,想了解可以点击原文地址或译文地址。 变量的块级作用域 这个特性是结合let,const实现的,极大地解决了var带来的麻烦,这里关于它们就不细细介绍了; 模版字符串 有了模版字符串就不必使用赘余的字符串嵌套了,看例子: 1234// ES5var first = 'Adrian';var last = 'Mejia';console.log('Your name is ' + first + ' ' + last + '.'); ES6中我们可以使用反引号`和字符串插值${} 123//ES6const first = 'Adrian', last = 'Mejia'; //这里没有使用varconsole.log(`Your name is $&#123;first&#125; $&#123;last&#125;.`); 多行字符串 我们也没必要用+\\n来拼接字符串了: 12345678910//ES5var template = '&lt;li *ngFor=\"let todo of todos\" [ngClass]=\"&#123;completed: todo.isDone&#125;\" &gt;\\n' +' &lt;div class=\"view\"&gt;\\n' +' &lt;input class=\"toggle\" type=\"checkbox\" [checked]=\"todo.isDone\"&gt;\\n' +' &lt;label&gt;&lt;/label&gt;\\n' +' &lt;button class=\"destroy\"&gt;&lt;/button&gt;\\n' +' &lt;/div&gt;\\n' +' &lt;input class=\"edit\" value=\"\"&gt;\\n' +'&lt;/li&gt;';console.log(template); 我们依旧可以用ES6的反引号来解决这个问题: 12345678910//ES6const template = `&lt;li *ngFor=\"let todo of todos\" [ngClass]=\"&#123;completed: todo.isDone&#125;\" &gt; &lt;div class=\"view\"&gt; &lt;input class=\"toggle\" type=\"checkbox\" [checked]=\"todo.isDone\"&gt; &lt;label&gt;&lt;/label&gt; &lt;button class=\"destroy\"&gt;&lt;/button&gt; &lt;/div&gt; &lt;input class=\"edit\" value=\"\"&gt;&lt;/li&gt;`;console.log(template); 上面两行代码的执行结果完全一样. 解构赋值 ES6的解构赋值超级实用并且十分简洁!贴个例子: 从数组中获取元素的值 12345// ES5var array = [1, 2, 3, 4];var first = array[0];var third = array[2];console.log(first, third); // 1 3 等同于: 1234//ES6const array = [1, 2, 3, 4];const [first, , third] = array;console.log(first, third); // 1 3 交换值 1234567//ES5var a = 1;var b = 2;var tmp = a;a = b;b = tmp;console.log(a, b); // 2 1 等同于: 1234//ES6let a = 1, b = 2;[a, b] = [b, a]console.log(a, b); // 2 1 多个返回值的解构 123456789// ES5function margin() &#123; var left=1, right=2, top=3, bottom=4; return &#123; left: left, right: right, top: top, bottom: bottom &#125;;&#125;var data = margin();var left = data.left;var bottom = data.bottom;console.log(left, bottom); // 1 4 等同于: 1234567// ES6function margin() &#123; const left=1, right=2, top=3, bottom=4; return &#123; left, right, top, bottom &#125;;&#125;const &#123; left, bottom &#125; = margin();console.log(left, bottom); // 1 4 这其中用到了ES6的其他语法,将{left: left}简化为{left}; 参数匹配的解构 12345678// ES5var user = &#123;firstName: 'Adrian', lastName: 'Mejia'&#125;;function getFullName(user) &#123; var firstName = user.firstName; var lastName = user.lastName; return firstName + ' ' + lastName;&#125;console.log(getFullName(user)); // Adrian Mejia 等同于: 12345const user = &#123;firstName: 'Adrian', lastName: 'Mejia'&#125;;function getFullName(&#123; firstName, lastName &#125;) &#123; return `$&#123;firstName&#125; $&#123;lastName&#125;`;&#125;console.log(getFullName(user)); // Adrian Mejia 原生Promises 从回调地狱到promises 12345678910111213// ES5function printAfterTimeout(string, timeout, done)&#123; setTimeout(function()&#123; done(string); &#125;, timeout);&#125;printAfterTimeout('Hello ', 2e3, function(result)&#123; console.log(result); // 嵌套回调 printAfterTimeout(result + 'Reader', 2e3, function(result)&#123; console.log(result); &#125;);&#125;); 回调的噩梦就不多说了,来看一下promises的写法: 1234567891011121314// ES6function printAfterTimeout(string, timeout)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(function()&#123; resolve(string); &#125;, timeout); &#125;);&#125;printAfterTimeout('Hello ', 2e3).then((result) =&gt; &#123; console.log(result); return printAfterTimeout(result + 'Reader', 2e3);&#125;).then((result) =&gt; &#123; console.log(result);&#125;); 箭头函数 ES6没有新增了一种函数表达式,箭头函数: 12345678// ES5var _this = this; // 保持一个引用$('.btn').click(function(event)&#123; _this.sendData(); // 引用的是外层的 this&#125;);$('.input').on('change',function(event)&#123; this.sendData(); // 引用的是外层的 this&#125;.bind(this)); // 绑定到外层的 this 我们需要一个临时的this在函数内部引用或用bind绑定,在ES6中我们可以用箭头函数: 123456// ES6// 引用的是外部的那个 this$('.btn').click((event) =&gt; this.sendData());// 隐式返回const ids = [291, 288, 984];const messages = ids.map(value =&gt; `ID is $&#123;value&#125;`); For…of 从for到forEach再到for...of: 1234567891011// ES5// forvar array = ['a', 'b', 'c', 'd'];for (var i = 0; i &lt; array.length; i++) &#123; var element = array[i]; console.log(element);&#125;// forEacharray.forEach(function (element) &#123; console.log(element);&#125;); ES6的for...of: 123456// ES6// for ...ofconst array = ['a', 'b', 'c', 'd'];for (const element of array) &#123; console.log(element);&#125; 默认参数 从检查一个变量是否被定义到重新指定一个值再到default parameters。 之前或许我们会这样写: 1234567891011// ES5function point(x, y, isFlag)&#123; x = x || 0; y = y || -1; isFlag = isFlag || true; console.log(x,y, isFlag);&#125;point(0, 0) // 0 -1 truepoint(0, 0, false) // 0 -1 truepoint(1) // 1 -1 truepoint() // 0 -1 true 如果你写过这样的代码,那么当然你也会知道这里面的坑(当然有办法解决),但利用ES6我们可以用更简洁的代码实现同样的功能: 12345678// ES6function point(x = 0, y = -1, isFlag = true)&#123; console.log(x,y, isFlag);&#125;point(0, 0) // 0 0 truepoint(0, 0, false) // 0 0 falsepoint(1) // 1 -1 truepoint() // 0 -1 true 剩余参数 从参数到剩余参数和扩展操作符: 在ES5中,获取任意数量的参数是非常麻烦的: 1234567// ES5function printf(format) &#123; var params = [].slice.call(arguments, 1); console.log('params: ', params); console.log('format: ', format);&#125;printf('%s %d %.2f', 'adrian', 321, Math.PI); 我们可以利用ES6中的rest操作符...来实现同样的功能: 123456// ES6function printf(format, ...params) &#123; console.log('params: ', params); console.log('format: ', format);&#125;printf('%s %d %.2f', 'adrian', 321, Math.PI); 展开运算符 从apply()到展开运算符,我们还是用...来解决: 12// ES5Math.max.apply(Math, [2,100,1,6,43]) // 100 在ES6中,我们可以运用...展开运算符: 12// ES6Math.max(...[2,100,1,6,43]) // 100 从concat到展开运算符: 12345// ES5var array1 = [2,100,1,6,43];var array2 = ['a', 'b', 'c', 'd'];var array3 = [false, true, null, undefined];console.log(array1.concat(array2, array3)); 在ES6中,我们可以运用展开运算符来取代嵌套: 12345// ES6const array1 = [2,100,1,6,43];const array2 = ['a', 'b', 'c', 'd'];const array3 = [false, true, null, undefined];console.log([...array1, ...array2, ...array3]); 屌屌的ES6,前端的路好长!","tags":[{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"ES6","slug":"ES6","permalink":"https://barefootChild.github.io/tags/ES6/"}]},{"title":"createBlog","date":"2016-11-01T11:54:02.000Z","path":"2016/11/01/createBlog/","text":"利用hexo和github pages搭建自己的博客何为Hexo? hexo的官方定义是:一个简单地,轻量的,基于node的一个静态博客网站框架;可以方便快捷地生成静态网页托管在github上; 何为gitHub Pages? 可以被认为是用户编写的,托管在github上的静态网页.空间免费哦! 何为github? 这个问题小编就不回答了,偷偷告诉你github是一个程序员必不可少的”左膀右臂”;有了它,你会觉得…还没有?那还在等什么?赶紧点击注册啊! 搭建过程需要配置很多文件,也需要很多知识(那种看看就会的,相信我,绝对比做一个产品的需求简单多了),下面就进入正题吧! 环境准备安装node安装?点击去官网啊! 安装gityes,点击去官网; 注册github(不多说了,作为程序员没有github账号的话,允许我鄙视5秒钟)安装Hexo npm install -g hexo 然后进行初始化我们的博客项目: hexo init 这样就生成了我们博客项目的文件夹,然后到该文件夹下看一下生成的文件内容,在该文件夹下执行下面代码,安装依赖: npm install 在该文件夹下你会发现下面这些文件: _config.yml : 博客项目的配置文件 package.json : 项目源信息以及项目依赖信息 scaffolds : 脚手架文件夹，当我们创建一个新的文章时，hexo就是根据scaffolds内的文件工作的 source : 博客项目源文件夹，里面的文件将被渲染处理并放入public文件夹 themes : 主题文件夹(我们可以通过更改该文件下的文件内容,更改我们博客的主题风格) 接下来我们就可以写新的文章了,通过下面的命令: hexo new ‘filename’ 执行完后我们会看到在source/_posts文件夹下会产生一个filename.md文件,该文件是按照markdown规格来写的,用来生成我们新博客的内容,所以如果不会就点击学习MarkDown写完文章后需要执行下面的命令进行编译: hexo generate And then, execute next: hexo server 就在本地4000端口起了服务了;还等什么?localhost:4000看效果啊!(小编忘记吃药了,见谅)很神奇的发现带有默认主题的博客就出现了,为什么会有样式?为什么?为什么?不要激动,还记得那个themes文件夹么?对就是它,不要怕点进去,看一下代码,尤其是source-src文件夹下的文件,很亲切吧,想改成自己喜欢的?just do it!如果想切换主题风格,点击hexo主题库自由地切换吧,安装新的主题到themes文件夹下,然后要对该主题下的_config.yml文件进行配置(不是项目根目录下的_config.yml,它也需要配置,但有别的用处) 部署到github(默认你已经有账号)在自己的账户下创建一个仓库，命名为 username.github.io ，注意：这个仓库名称是固定的，将username替换成你的github用户名。然后修改博客根目录下的配置文件_config.ylm: 123456# Deployment## Docs: http://hexo.io/docs/deployment.htmldeploy: type: git repo: https://github.com/username/username.github.io.git branch: master 配置好之后，还需要在自己的github上添加 SSH Key，如何生成SSH Key以及如何配置添加,请点击SSH Key;添加SSH Key后安装一个插件: npm install –save hexo-deploy-git 然后,last step: hexo deploy 部署成功,赶紧浏览器输入username.github.io查看自己的博客吧!项目根目录下的_config.yml配置详情,点击_config.yml 当然也可以点击博主查看我的博客配置文件,感觉可以就点个star吧! 通篇博文看下来,或许你会感觉博主很懒,什么配置啊,安装啊都连接到其它处! 没错,具体配置什么的,要自己去官网看,官方文档写得很仔细,也是最权威的地方,每个人看都希望追求个性,还望大家,自己查阅,按照自己的喜好配置,博主只是提供路径!","tags":[{"name":"hexo","slug":"hexo","permalink":"https://barefootChild.github.io/tags/hexo/"},{"name":"git","slug":"git","permalink":"https://barefootChild.github.io/tags/git/"},{"name":"yilia","slug":"yilia","permalink":"https://barefootChild.github.io/tags/yilia/"},{"name":"gitHub Pages","slug":"gitHub-Pages","permalink":"https://barefootChild.github.io/tags/gitHub-Pages/"}]},{"title":"arithmetic-js","date":"2016-11-01T06:00:54.000Z","path":"2016/11/01/arithmetic-js/","text":"javascript中常见的算法问题 关于这些方法的总结,是本人在浏览前端干货时发现的有趣的东西,您可以点击阅读原文去查看原文(原文有些方法不对,可亲测); 判断一个单词是否是回文? 回文单词就是指该单词倒置后和原单词完全一样; 123function checkPalindrom(str)&#123; return str == str.split('').reverse().join(''); &#125; 去掉一组整型数组重复的值 1234567891011function unique(arr)&#123; let obj = &#123;&#125;; let data = []; for (let i = 0, l = arr.length; i &lt; l; i++) &#123; if (!obj[arr[i]]) &#123; obj[arr[i]] = true; data.push(arr[i]); &#125; &#125; return data;&#125; 统计一个字符串出现最多的字母1234567891011121314151617181920212223function findMaxDuplicateChar(str) &#123; if (str.length === 1) &#123; return str; &#125; let obj = &#123;&#125;; for (let i = 0, l = str.length; i &lt; l; i++) &#123; if (!obj[str.charAt(i)]) &#123; obj[str.charAt(i)] = 1; &#125; else &#123; obj[str.charAt(i)] +=1; &#125; &#125; let maxChar = '', maxValue = 1; for (let k in obj) &#123; if (obj[k] &gt;= maxValue) &#123; maxValue = obj[k]; maxChar = k; &#125; &#125; return maxChar;&#125; 排序算法 冒泡排序12345678910111213function bubbleSort(arr) &#123; for (let i = 0, l = arr.length; i &lt; l; i++) &#123; for (let j = i+1; j &lt; l; j++) &#123; if (arr[i] &gt; arr[j]) &#123; let tem = arr[i]; arr[i] = arr[j]; arr[j] = tem; &#125; &#125; &#125; return arr;&#125; 快速排序123456789101112131415161718function quickSort(arr) &#123; if (arr.length &lt;= 1) &#123; return arr; &#125; let leftArr = []; let rightArr = []; let q = arr[0]; for (let i = 1, l = arr.length; i &lt; l; i++) &#123; if (arr[i] &gt; q) &#123; rightArr.push(arr[i]); &#125; else &#123; leftArr.push(arr[i]); &#125; &#125; return [].concat(auickSort(leftArr), [q], quickSort(rightArr));&#125; 不借助中间变量,进行两个整数的变换123456function swap(a, b) &#123; b = b - a; a = a + b; b = a - b; return [a,b];&#125; es6(so easy!) 1[a, b] = [b, a] 随机生成指定长度的字符串1234567891011function randomString(n) &#123; let str = 'abcdefghijklmnopqrstuvwxyz9876543210'; let tmp = '', i = 0, l = str.length; for (i = 0; i &lt; n; i++) &#123; tmp += str.charAt(Math.floor(Math.random() * 1)); &#125; return tmp;&#125; 找出正数数组的最大差值(原文对于该方法的书写是错误的,亲测,其它方法都很棒!值得追捧)12345function getMaxProfit(arr) &#123; let minValue = Math.min(...arr); let maxValue = Math.max(...arr); return maxValue - minValue;&#125;","tags":[{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"arithmetic","slug":"arithmetic","permalink":"https://barefootChild.github.io/tags/arithmetic/"},{"name":"methods","slug":"methods","permalink":"https://barefootChild.github.io/tags/methods/"}]},{"title":"javascript-copy","date":"2016-10-25T11:33:22.000Z","path":"2016/10/25/javascript-copy/","text":"该篇博客的由来 需求第一,有这个需求; 网上copy不到可用的代码,如果能找到傻子才自己写呢; 一直想搞个博客,终于将想法付诸于实践了,第一次撸博客,很开心有木有; 为了实现这个需求,我这个前端小菜在网上看了很多博文,查了很多资料,奈何很多都是用的window.clipboardData.setData()之类的,现在的浏览器好像都不支持这个属性的;另外有些就是写得很杂很乱,没有封装成一个方法,并且兼容性不好;所以,为了自己以后用得方便,就封装了一个自认为不错的方法(至少满足了自己的需求):copyText代码奉上,欢迎指正: 代码奉上 123456789101112131415161718192021function copyText(ele)&#123; function otherEle(element)&#123; if (document.selection) &#123; var range = document.body.createTextRange(); range.moveToElementText(element); range.select(); &#125;else&#123; window.getSelection().removeAllRanges(); var range = document.createRange(); range.selectNode(element); window.getSelection().addRange(range); &#125; &#125; if(ele.select)&#123; ele.select(); &#125;else&#123; otherEle(ele); &#125; document.execCommand('Copy'); window.getSelection().removeAllRanges(); &#125; 该方法只需要传入一个参数(你需要复制内容的DOM元素);","tags":[{"name":"javascript","slug":"javascript","permalink":"https://barefootChild.github.io/tags/javascript/"},{"name":"copy","slug":"copy","permalink":"https://barefootChild.github.io/tags/copy/"}]}]